###

RT_PRODUCTS 테이블은 장바구니에 담긴 상품 정보를 담은 테이블입니다. CART_PRODUCTS 테이블의 구조는 다음과 같으며, ID, CART_ID, NAME, PRICE는 각각 테이블의 아이디, 장바구니의 아이디, 상품 종류, 가격을 나타냅니다.

NAME TYPE
ID INT
CART_ID INT
NAME VARCHAR
PRICE INT
문제
각 상품 종류를 담은 장바구니가 몇 개인지 조회하는 SQL 문을 작성해주세요. 한 장바구니가 같은 상품 종류를 여러 번 담았더라도 이 상품 종류를 담은 장바구니는 한 개로 칩니다. 결과는 사전 순으로 앞서는 상품 종류를 먼저 보여주세요.

예시
예를 들어 CART_PRODUCTS 테이블이 다음과 같다면

ID CART_ID NAME PRICE
3728 195 Ketchup 1380
5687 301 Ice Cream 3980
5696 301 Coffee 24800
5697 301 Coffee 24800
10156 531 Ice Cream 3980
Ketchup을 담은 장바구니는 195번 장바구니 하나입니다.
Ice Cream을 담은 장바구니는 301번, 531번 장바구니 두 개입니다.
Coffee를 장바구니는 301번 장바구니 하나입니다. 301번 장바구니는 Coffee를 두 번 담았지만, 같은 장바구니에 담겼으므로 Coffee를 담은 장바구니 수는 하나로 칩니다.
따라서 SQL 문을 실행하면 다음과 같이 나와야 합니다.

NAME 장바구니 수
Coffee 1
Ice Cream 2
Ketchup 1
######3
SQL
다시 풀 문제
문제 설명
EMPLOYEES 테이블은 자동차 판매 회사 직원의 정보를 담은 테이블입니다. EMPLOYEES 테이블 구조는 다음과 같으며, ID, NAME, SALARY, BRANCH_ID는 각각 직원의 아이디, 이름, 월급, 근무하는 대리점 아이디를 나타냅니다.

NAME TYPE NULLABLE
ID INT FALSE
NAME VARCHAR(N) FALSE
SALARY NUMERIC(N,M) FALSE
BRANCH_ID INT FALSE
BRANCHES 테이블은 자동차 판매사 대리점 정보를 담은 테이블입니다. BRANCHES테이블 구조는 다음과 같으며, ID, NAME, ADDRESS는 각각 대리점의 아이디, 지점명, 주소를 나타냅니다.

NAME TYPE NULLABLE
ID INT FALSE
NAME VARCHAR(N) FALSE
ADDRESS VARCHAR(N) FALSE
SELLINGS 테이블은 자동차 판매 기록을 담은 테이블입니다. SELLINGS 테이블 구조는 다음과 같으며, CAR_ID, EMPLOYEE_ID, CREATED_AT, PRICE는 각각 판매한 자동차의 ID, 자동차를 판매한 사원의 ID, 판매일, 판매 가격을 나타냅니다.

NAME TYPE NULLABLE
CAR_ID INT FALSE
EMPLOYEE_ID INT FALSE
CREATED_AT DATETIME FALSE
PRICE NUMERIC(N,M) FALSE
문제
주소가 '서울특별시'로 시작하는 대리점의 ID, 지점명, 주소와 해당 대리점이 자동차를 몇 대 팔았는지를 나타내는 SQL문을 작성해주세요. 이때 결과는 대리점의 ID 순으로 오름차순 정렬해 주세요.

예시
예를 들어 EMPLOYEES, BRANCHES, SELLINGS 테이블이 다음과 같다면

EMPLOYEES

ID NAME SALARY BRANCH_ID
2455 Giuliana 300 1
3108 Abriella 330 1
3216 Jaliyah 250 5
3232 Andrea 370 7
3700 Jamie 370 4
BRANCHES

ID NAME ADDRESS
1 강남 서울특별시 강남구 테헤란로
4 도곡 서울특별시 강남구 언주로
5 삼성역 서울특별시 강남구 테헤란로
7 대치센트레빌 서울시 강남구 남부순환로
SELLINGS

CAR_ID EMPLOYEE_ID CREATED_AT PRICE
352 2455 2016-08-16 2:52 3700
369 3232 2016-12-09 7:56 7500
306 3700 2016-12-23 9:49 18200
403 3108 2016-11-20 2:54 19200
352 3216 2016-12-14 10:45 13100
ID가 1인 '강남' 지점에서는 'Giuliana' 직원과 'Abriella' 직원이 각각 1대씩 자동차를 팔았습니다.
ID가 4인 '도곡' 지점에서는 'Jamie' 직원이 자동차를 1대 팔았습니다.
ID가 5인 '삼성역' 지점에서는 'Jaliyah' 직원이 자동차를 1대 팔았습니다.
ID가 7인 '대치센트레빌' 지점은 주소가 서울특별시로 시작하지 않습니다.

따라서 SQL문을 실행하면 다음과 같이 출력되어야 합니다.

ID NAME ADDRESS COUNT
1 강남 서울특별시 강남구 테헤란로 2
4 도곡 서울특별시 강남구 언주로 1
5 삼성역 서울특별시 강남구 테헤란로 1
12
-- 코드를 입력하세요
SELECT
실행 결과
실행 결과가 여기에 표시됩니다.

##############
문제 설명
CART_PRODUCTS 테이블은 장바구니에 담긴 상품 정보를 담은 테이블입니다. CART_PRODUCTS 테이블의 구조는 다음과 같으며, ID, CART_ID, NAME, PRICE는 각각 테이블의 아이디, 장바구니의 아이디, 상품 종류, 가격을 나타냅니다.

NAME TYPE
ID INT
CART_ID INT
NAME VARCHAR
PRICE INT
COUPONS 테이블은 장바구니에 적용된 쿠폰 정보를 담은 테이블입니다. COUPONS 테이블의 구조는 다음과 같으며, ID, CART_ID, MINIMUM_REQUIREMENT, DISCOUNT_AMOUNT는 각각 쿠폰의 아이디, 쿠폰이 적용된 장바구니의 아이디, 최소 주문 금액, 할인 금액을 나타냅니다. 예를 들어, MINIMUM_REQUIREMENT가 50,000인 쿠폰은 (쿠폰 적용 전) 상품 가격 합이 50,000 이상인 장바구니에만 적용할 수 있습니다.

NAME TYPE
ID INT
CART_ID INT
MINIMUM_REQUIREMENT INT
DISCOUNT_AMOUNT INT
문제
장바구니에 들은 상품의 가격 합이 쿠폰의 최소 주문 금액 미만이어도 쿠폰이 적용되는 버그를 발견하였습니다. COUPONS 테이블에 주어진 모든 장바구니의 아이디와, 해당 장바구니에 버그가 악용되었는지 조회하는 SQL 문을 작성해주세요. 버그가 악용되었다면 1, 아니라면 0를 표시해주세요. 또한 결과는 장바구니의 아이디 순으로 나와야 합니다.

예시
예를 들어 CART_PRODUCTS 테이블과 COUPONS 테이블이 다음과 같다면

CART_PRODUCTS 테이블

ID CART_ID NAME PRICE
5508 287 Facial Tissue 10900
5509 287 Dish Detergent 4900
5510 287 Vegetable 2480
8434 448 Toilet Paper 19500
8452 448 Diaper 18900
8436 448 Laundry Care 12900
19129 977 Yogurt 2980
19130 977 Butter 4890
19131 977 Chicken 6180
COUPONS 테이블

ID CART_ID MINIMUM_REQUIREMENT DISCOUNT_AMOUNT
0 287 100000 9000
3 977 50000 5000
5 448 50000 3000
287번 장바구니에 담긴 상품의 가격 합은 10900 + 4900 + 2480 = 18,280입니다. 장바구니에 적용된 쿠폰의 최소 주문 금액은 100,000이므로 이 장바구니에는 버그가 악용되었습니다.
448번 장바구니에 담긴 상품의 가격 합은 19500 + 18900 + 12900 = 51,300입니다. 장바구니에 적용된 쿠폰의 최소 주문 금액은 50,000이므로 이 장바구니에는 버그가 악용되지 않았습니다.
977번 장바구니에 담긴 상품의 가격 합은 2980 + 4890 + 6180 = 14,050입니다. 장바구니에 적용된 쿠폰의 최소 주문 금액은 50,000이므로 이 장바구니에는 버그가 악용되었습니다.
따라서 SQL 문을 실행하면 다음과 같이 나와야 합니다.

CART_ID ABUSED
287 1
448 0
977 1

ui 유저 인터페이스
ux 사용적인 친화도 디자인
문제 설명
다음 조건을 만족하는 수를 자기표현수라고 합니다.

B진법(단, 2 ≤ B ≤ 10) N자리(단, N ≤ B) 수의 가장 왼쪽 자리부터 순서대로 0, 1 ... N - 1과 같이 번호를 붙입니다.
원래 수에서 0 ~ N - 1의 숫자가 나타난 횟수를 각 번호마다 적습니다. N - 1보다 큰 숫자는 무시합니다.
원래 수와 2단계에서 적은 수를 이어붙인 수가 같으면 자기표현수입니다.
10진법 자연수 number가 매개변수로 주어질 때, 이를 2진법 ~ 10진법으로 나타냈을 때 자기표현수라면 해당 진법을 return 하도록 solution 함수를 완성해주세요. 만약 자기표현수가 아니라면 -1을 return 하면 됩니다.

제한사항
number는 1 이상 100,000,000 이하인 자연수입니다.
자기표현수가 되는 진법이 한 가지인 경우만 입력으로 주어집니다.
입출력 예
number result
1210 10
1425 5
100 4
9876 -1
입출력 예 설명
입출력 예 #1

10진법 1210은 조건에 따라 다음과 같이 나타낼 수 있습니다.

번호 0 1 2 3
숫자 1 2 1 0
이는 0이 1번, 1이 2번, 2가 1번, 3이 0번 나타났다는 의미이며, 원래 숫자 1210과 같으므로 자기표현수입니다.

입출력 예 #2

1425를 5진법으로 나타내면 21200이 되며, 다음과 같이 나타낼 수 있습니다.

번호 0 1 2 3 4
숫자 2 1 2 0 0
이는 0이 2번, 1이 1번, 2가 2번, 3이 0번, 4가 0번 나타났다는 의미이며, 원래 숫자 21200과 같으므로 자기표현수입니다.

입출력 예 #3

100을 4진법으로 나타내면 1210이 되며, 이는 다음과 같이 자기표현수입니다.

번호 0 1 2 3
숫자 1 2 1 0
입출력 예 #6

10진법 9876을 조건에 따라 나타내면 다음과 같습니다.

번호 0 1 2 3
숫자 0 0 0 0
이 외에 다른 진법으로 나타내도 조건대로 나타낼 수 없으므로 자기표현수가 아닙니다.

#########
문제 설명
공을 던져서 인형을 맞추는 게임을 하려고 합니다. 인형들은 가로 방향으로 일렬로 놓여있으며, 인형 하나당 한 번씩 맞출 기회가 주어지고, 가장 왼쪽에 있는 인형부터 하나씩 순서대로 게임을 진행해야 합니다. 점수 계산 방식은 다음과 같습니다.

가장 왼쪽에 있는 인형의 점수는 1점이며, 오른쪽으로 갈수록 1점씩 증가합니다.
왼쪽에서 첫 번째 인형 = 1점, 두 번째 인형 = 2점, 세 번째 인형 = 3점...
인형을 맞추면 점수를 획득하며, 만약 연속으로 인형을 맞추면 가산점을 부여합니다.
k번 연속으로 인형을 맞춘다면 [맞춘 인형의 점수] x k점을 얻게 됩니다.
인형을 맞출 때마다 획득한 점수가 총점에 더해집니다.
인형을 맞추지 못하면 0점을 획득하며, 연속으로 맞춘 횟수가 다시 0이 됩니다.
왼쪽부터 나열된 인형을 차례대로 맞추었는지 여부를 알려주는 채점표 v가 주어질 때, 총점을 return 하도록 solution 함수를 완성해 주세요.
단, 채점표에는 인형을 맞추면 1, 그렇지 못하면 0이 적혀 있습니다.

제한사항
채점표 v는 0과 1로만 이루어져 있습니다.
채점표 v의 길이 : 1,000 이하의 자연수
입출력 예
v answer
[0,1,1,0,1,1,1,0] 46
입출력 예 설명
입출력 예 #1

인형 순서 채점표 v 획득 점수
1 0 0점
2 1 2점
3 1 6점 (2회 연속)
4 0 0점
5 1 5점
6 1 12점 (2회 연속)
7 1 21점 (3회 연속)
8 0 0점
예를 들어 7번째 인형은 5번째 인형부터 연속으로 3번 맞췄으므로 (인형 점수 7점) x 3 = 21점을 획득합니다. 획득 점수를 모두 합하면 총점은 46점이 됩니다.
