문제 설명
상태 미세먼지 농도
좋음 30 이하
보통 31 ~ 80
나쁨 81 ~ 150
매우나쁨 151 이상
상태 초미세먼지 농도
좋음 15 이하
보통 16 ~ 35
나쁨 36 ~ 75
매우나쁨 76 이상
위의 표는 미세먼지/초미세먼지의 농도에 따른 대기의 상태를 나타냅니다. 매일 외출을 해야 하는 민우는 미세먼지나 초미세먼지의 농도가 어느 하나라도 나쁨이상으로 올라가면 마스크(입자 차단 마스크)를 착용합니다.
원칙적으로 마스크는 재사용이 권장되지 않습니다. 하지만 마스크 품귀 현상으로 쉽게 구매하기 어려워진 민우는 마스크를 재사용하되, 다음과 같은 기준을 세웠습니다.

새 마스크를 착용한 날로부터 이틀 후까지만 재사용하고 폐기합니다.
즉, 민우가 새 마스크를 착용한 날이 day일이라면, day+2일까지 사용한 후 폐기합니다.
day+1일, day+2일에 대기 상태가 좋아서 마스크를 재사용하지 않았더라도, 세균이 증식할 수 있으므로 day+2일 자정에 마스크를 폐기합니다.
단, 미세먼지/초미세먼지의 농도가 둘 다 매우나쁨상태가 되는 날은 사용하던 마스크를 그날까지만 쓰고, 더 이상 재사용하지 않고 폐기합니다.
DAY 1 2 3 4 5 6 7 8
미세먼지 농도 80 70 (100) 75 (160) 77 (181) (151)
초미세먼지 농도 35 (38) (41) 30 (80) 29 (68) (76)
마스크 - 첫 사용 재사용 폐기 첫 사용 후 폐기 - 첫 사용 재사용 후 폐기
위의 표는 8일간의 미세먼지/초미세먼지 농도 예보와 그에 따른 민우의 마스크 사용 패턴를 예측한 것입니다.(나쁜 농도를 ( )로, 매우 나쁜 농도를 ( )와 밑줄로 표시하였습니다.)
DAY 2, 5, 7에 새로운 마스크가 필요하므로, 8일간 총 3개의 마스크가 필요할 것입니다.

미세먼지/초미세먼지 농도에 대한 예보를 담고 있는 2차원 정수 배열 atmos가 매개변수로 주어집니다. 이때, 민우에게 필요한 마스크의 개수를 return 하도록 solution 함수를 완성해주세요.

제한사항
atmos의 길이는 1 이상 1,000 이하입니다.
atmos에는 예보 첫날(DAY 1)부터 마지막 날까지의 미세먼지/초미세먼지 농도가 차례대로 담겨 있습니다.
atmos의 원소들은 [a, b] 형태입니다.
a는 미세먼지의 농도를 나타내며, 0 이상 1,000 이하인 정수입니다.
b는 초미세먼지의 농도를 나타내며, 0 이상 1,000 이하인 정수입니다.
입출력 예
atmos result
[[80, 35], [70, 38], [100, 41], [75,30], [160,80], [77, 29], [181, 68], [151, 76]] 3
[[140, 90], [177, 75], [95, 45], [71, 31], [150, 30], [80, 35], [72, 33], [166, 81], [151, 75]] 4
[[30, 15], [80, 35]] 0
입출력 예 설명
입출력 예 #1
문제 예시와 같습니다.

입출력 예 #2

DAY 1 2 3 4 5 6 7 8 9
미세먼지 농도 (140) (177) (95) 71 (150) 80 72 (166) (151)
초미세먼지 농도 (90) (75) (45) 31 30 35 33 (81) (75)
마스크 첫 사용 재사용 재사용 후 폐기 - 첫 사용 - 폐기 첫 사용 후 폐기 첫 사용
DAY 1, 5, 8, 9에 새 마스크가 필요하므로, 4를 return 해야 합니다.

입출력 예 #3

DAY 1 2
미세먼지 농도 30 80
초미세먼지 농도 15 35
마스크 - -
마스크가 필요한 날이 없으므로, 0을 return 해야 합니다.

/\*\*
function solution(atmos) {

    // 다차원 배열 1차원 쪼개기
    // 초미세 변수 선언 및 조건 설정 return 0
    // 미세  변수 선언 및 조건 설정 return 0
    // 초미세  || 미세가 나쁨이 되었을때  날짜 = index push하기
    // 날짜조건 (각인덱스 별로 >3 이상일때만 )

    let newArr = atmos.reduce(function (acc, cur) {
        return acc.concat(cur)
    })
    let filters = new Array();

    let micro = [];
    let fineMi = [];
    for (let i = 0; i < atmos.length; i++) {
        for (let j = 0; j < atmos.length; j++) {
            micro = newArr[2 * i];
            fineMi = newArr[2 * i + 1];
            filters.push(micro, fineMi);
            //  if(micro <81 || fineMi <36  ){
            //      return 0;
            //  }
            // const isMatch = (ele => ele = filter[i])

            // for (let j = 0; j < atmos.length; j++) {
            //atmos.indexOf(filter[j]) //undefined
            let sum = atmos.filter(ele => {
                ele[i][j] = filters[i]



            });

            //console.log(atmos.findIndex(isMatch))
        }
    } return 0;

}

        // //console.log("F", fineMi)
        // if (micro > 80 || fineMi > 35) {
        //     filter.push(micro,fineMi)
        //     i++;

        // } else {
        //     return 0;
        // }

//console.log(filter)
// }

//}

/\*\*

- 나쁨의 기준?
- 초미세 >36 이상
- 미세 > 81이상
-
- +\_2일까지 사용간으
- 첫사용 재사용 폐기
- 첫사용 x 폐기
- 첫사용 폐기
- 첫사용+폐기 xx
-
- \*/
  \*\*/
  #2
  문제 설명
  XX사 직원들이 근무하는 빌딩은 업무를 위한 사무실이 여러층에 걸쳐 나누어져 있습니다. 모든 사무실은 호수로 구분하며, 사무실마다 직원들을 위한 자리가 마련되어 있습니다. XX사의 모든 직원은 각자 지정된 자리를 하나 이상 사용하며, 현재 주인이 없는 빈자리는 없다고 합니다. 단, 한 사람이 한 사무실에서 지정된 자리를 두 개 이상 사용하지는 않습니다.

오늘, 사무실 중 한 곳에 새 책상을 들여놓으면서 주인 없는 빈자리가 하나 생겼습니다. 이 자리를 기존 직원 중 한 사람에게 다음 규칙에 따라 주려 합니다.

해당 방에 이미 지정 자리가 있는 직원은 제외합니다.
지정 자리가 제일 적은 직원의 우선순위가 가장 높습니다.
지정 자리의 개수가 동일한 사람들끼리는 새 자리가 생긴 방에서 가장 가까운 방에 지정 자리가 있는 직원이 우선순위가 더 높습니다.
한 사람의 지정 자리가 여러 개인 경우, 지정 자리가 있는 방 중에서 새 자리가 생긴 방과 가장 가까운 방을 기준으로 선정합니다.
방과 방 사이의 거리는 두 방의 호수 차이의 절댓값으로 정의합니다.
예를 들어 303호와 405호의 거리는 |303 - 405| = 102입니다.
지정 자리 수와 새 자리가 생긴 방까지의 거리도 동일한 경우, 이름이 사전 순으로 빠른 사람이 더 높은 우선순위를 갖습니다. 단 사전 순은 대문자가 소문자 보다 사전 순으로 앞섭니다. 예를 들어, A~Z, a~z까지 알파벳을 사전 순으로 정렬한 결과는 [A, B, ... Z, a, b, ... , z]입니다
직원들의 지정 자리 정보가 담긴 배열 rooms와 새 자리가 생긴 방 호수 target이 매개변수로 주어집니다. 새 자리를 받을 수 있는 사람들을 우선순위가 높은 사람부터 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요.

제한 사항
rooms의 길이는 2 이상 5,000 이하입니다.
rooms의 원소는 [방 호수]이름1,이름2,...형식의 문자열입니다.
예를 들어, "[1201]Azad,Guard"는 1201호에 "Azad"와 "Guard"의 자리가 있다는 뜻입니다.
방 호수는 3글자 또는 4글자의 숫자들로 이루어진 문자열입니다.
방 호수는 101 이상 9,999 이하인 자연수입니다.
이름은 알파벳 대소문자로 이루어진 길이가 1 이상 10 이하인 문자열입니다.
주어진 데이터에 나오는 서로 다른 사람은 1명 이상 100,000명 이하입니다.
동명이인은 없으며, 이름은 대소문자를 구분합니다.
예를 들어 Andy와 andy는 서로 다른 사람입니다.
target은 새로 자리가 생긴 방의 호수입니다.
target은 rooms 데이터에 등장하는 방 중 하나입니다.
새 자리를 받을 수 있는 사람이 1명 이상인 경우만 입력으로 주어집니다.
입출력 예시
rooms target result
["[403]James", "[404]Azad,Louis,Andy", "[101]Azad,Guard"] 403 ["Andy", "Louis", "Guard", "Azad"]
["[101]Azad,Guard", "[202]Guard", "[303]Guard,Dzaz"] 202 ["Azad", "Dzaz"]
["[1234]None,Of,People,Here","[5678]Wow"] 1234 ["Wow"]
입출력 예 설명
입출력 예 #1

이름 지정 자리 위치 새 자리까지 거리 우선순위
"Andy" 404 1 1
"Azad" 404, 101 1 4
"Guard" 101 302 3
"Louis" 404 1 2
"James" 403 0 -
403호에 James, 404호에 Azad/Louis/Andy, 101호에 Azad/Guard의 지정 자리가 있습니다.
새 자리가 생긴 방은 403호이므로, James는 고려 대상에서 제외됩니다.
Azad는 지정 자리가 2개이므로, 마지막 우선순위입니다.
Andy, Louis가 Guard보다 403호에 더 가까우므로, Guard는 3번째 우선순위입니다.
Andy가 Louis보다 사전 순으로 더 빠르므로, Andy가 1번째 우선순위, Louis가 2번째 우선순위입니다.
입출력 예 #2

이름 지정 자리 위치 새 자리까지 거리 우선순위
"Azad" 101 101 1
"Dzaz" 303 101 2
"Guard" 101, 202, 303 0 -
Azad와 Dzaz는 202호로부터 동일하게 떨어진 거리에 자리를 잡고 있습니다. 하지만, Azad가 사전 순으로 더 빠르므로, Azad가 더 높은 우선순위입니다.
입출력 예 #3

1234호에 새 자리가 생겼으며, 5678호에서 근무하는 "Wow" 혼자 자리를 받을 수 있습니다.

#3
문제 설명
다음 그림과 같이 qwerty식으로 구성된 2행의 키보드가 있습니다.

keyboard.png

당신에게 어떤 문자열이 주어집니다. 당신은 왼손의 검지손가락과 오른손의 검지손가락을 이용하여 이 문자열을 타이핑해야 합니다. 처음에는 왼손 검지는 'Q', 오른손 검지는 'P'에 있습니다.

매 글자를 누를 때마다, 다음과 같은 기준으로 거쳐 왼손 검지 또는 오른손 검지 중 하나를 선택하여 해당 키를 누릅니다.

왼손 검지와 오른손 검지로부터의 맨하탄 거리(수평거리 + 수직거리)가 다를 경우, 더 가까운 쪽의 손가락을 이용하여 키를 누릅니다.
두 맨하탄 거리가 같을 경우, 수평거리가 더 가까운 쪽의 손가락을 이용하여 키를 누릅니다.
수평거리도 동일할 경우, 해당 키가 키보드 상의 왼쪽('1', '2', '3', '4', '5', 'Q', 'W', 'E', 'R', 'T')에 있을 경우 왼손 검지를 이용해서 누르고, 키보드 상의 오른쪽('6', '7', '8', '9', '0', 'Y', 'U', 'I', 'O', 'P')에 있을 경우 오른손 검지를 이용해서 누릅니다.
키를 누른 이후, 두 손가락은 맨 처음의 위치로 이동하지 않고, 누른 키의 위치에 대기합니다.

타이핑해야 할 문자열 line이 매개변수로 주어집니다. 각 글자에 대해 왼손으로 키를 눌러야 하면 0, 오른손으로 키를 눌러야 하면 1을 배열에 담아 return 하도록 solution 함수를 완성해주세요.

제한 사항
line의 길이는 1 이상 10,000 이하입니다.
line은 '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'로 이루어진 문자열입니다.
입출력 예
line result
"Q4OYPI" [0,0,1,0,1,1]
"RYI76" [0,0,1,1,0]
"64E2" [1,1,1,0]
입출력 예 설명
입출력 예 #1

각 글자에 해당하는 키를 클릭한 직후 왼손 검지와 오른손 검지의 위치는 다음과 같습니다.
누를 글자 왼손 검지 위치 맨하탄 거리 수평 거리 오른손 검지 위치 맨하탄 거리 수평 거리 사용할 손
'Q' 'Q' 0 0 'P' 9 9 왼손
'4' 'Q' 4 3 'P' 7 6 왼손
'O' '4' 6 5 'P' 1 1 오른손
'Y' '4' 3 2 'O' 3 3 왼손
'P' 'Y' 4 4 'O' 1 1 오른손
'I' 'Y' 2 2 'P' 2 2 오른손
입출력 예 #2

각 글자에 해당하는 키를 클릭한 직후 왼손 검지와 오른손 검지의 위치는 다음과 같습니다.
누를 글자 왼손 검지 위치 맨하탄 거리 수평 거리 오른손 검지 위치 맨하탄 거리 수평 거리 사용할 손
'R' 'Q' 3 3 'P' 6 6 왼손
'Y' 'R' 2 2 'P' 4 4 왼손
'I' 'Y' 2 2 'P' 2 2 오른손
'7' 'Y' 2 1 'I' 2 1 오른손
'6' 'Y' 1 0 '7' 1 1 왼손
입출력 예 #3

각 글자에 해당하는 키를 클릭한 직후 왼손 검지와 오른손 검지의 위치는 다음과 같습니다.
누를 글자 왼손 검지 위치 맨하탄 거리 수평 거리 오른손 검지 위치 맨하탄 거리 수평 거리 사용할 손
'6' 'Q' 6 5 'P' 5 4 오른손
'4' 'Q' 4 3 '6' 2 2 오른손
'E' 'Q' 2 2 '4' 2 1 오른손
'2' 'Q' 2 1 'E' 2 1 왼손

문제 설명
CART_PRODUCTS 테이블은 장바구니에 담긴 상품 정보를 담은 테이블입니다. CART_PRODUCTS 테이블의 구조는 다음과 같으며, ID, CART_ID, NAME, PRICE는 각각 테이블의 아이디, 장바구니의 아이디, 상품 종류, 가격을 나타냅니다.

NAME TYPE
ID INT
CART_ID INT
NAME VARCHAR
PRICE INT
문제
데이터 분석 팀에서는 상품 X를 샀을 때 상품 Y를 살 확률을 알아보려 합니다. 이를 위해 여러분은 서로 다른 두 아이템 쌍을 담은 장바구니 수를 구하려 합니다. 서로 다른 두 상품 X, Y을 동시에 담은 장바구니의 수를 조회하는 SQL 문을 작성해주세요. 상품 쌍을 담은 장바구니가 하나도 없는 경우, 이 상품 쌍에 대한 정보는 결과에 포함하지 않습니다. 또한 결과는 상품 X와 Y의 이름 순으로 보여주세요.

예시
예를 들어 CART_PRODUCTS 테이블이 다음과 같다면

CART_PRODUCTS 테이블

ID CART_ID NAME PRICE
1632 83 Vegetable 2480
1633 83 Sausages 3980
1634 83 Vegetable 2480
5510 287 Vegetable 2480
5513 287 Sausages 3980
5514 287 Coffee 24800
(Vegetable, Sausages) 상품 쌍을 담은 장바구니는 83, 287번 장바구니 두 개 입니다.
(Sausages, Vegetable) 상품 쌍을 담은 장바구니는 83, 287번 장바구니 두 개 입니다.
(Vegetable, Coffee) 상품 쌍을 담은 장바구니는 287번 장바구니 하나입니다.
(Coffee, Vegetable) 상품 쌍을 담은 장바구니는 287번 장바구니 하나입니다.
(Sausages, Coffee) 상품 쌍을 담은 장바구니는 287번 장바구니 하나입니다.
(Coffee, Sausages) 상품 쌍을 담은 장바구니는 287번 장바구니 하나입니다.
결과는 상품 X와 Y의 이름 순으로 조회해야 하므로, SQL 문을 실행하면 다음과 같이 나와야 합니다.

NAME_X NAME_Y 장바구니 수
Coffee Sausages 1
Coffee Vegetable 1
Sausages Coffee 1
Sausages Vegetable 2
Vegetable Coffee 1
Vegetable Sausages 2
